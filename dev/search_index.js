var documenterSearchIndex = {"docs":
[{"location":"FixedPoint/#FixedPointToolkit.FPoint","page":"Fixed Point calculation","title":"FixedPointToolkit.FPoint","text":"","category":"section"},{"location":"FixedPoint/","page":"Fixed Point calculation","title":"Fixed Point calculation","text":"Modules = [FixedPointToolkit, FixedPointToolkit.FPoint]\nPrivate = false\nPages   = [FixedPoint.jl\"]","category":"page"},{"location":"FixedPoint/#FixedPointToolkit.FPoint.ContinueFixedPoint!-Union{Tuple{R}, Tuple{T}, Tuple{String, T, R}} where {T<:Function, R<:Function}","page":"Fixed Point calculation","title":"FixedPointToolkit.FPoint.ContinueFixedPoint!","text":"ContinueFixedPoint!(fileName::String, F::T, Update::R) where {T<:Function, R<:Function}\n\nReruns a fixed point iteration on the SelfCons reconstructed from the checkpoint saved in the JLD2 file fileName.\n\n\n\n\n\n","category":"method"},{"location":"FixedPoint/#FixedPointToolkit.FPoint.FixedPoint!-Tuple{SelfCons}","page":"Fixed Point calculation","title":"FixedPointToolkit.FPoint.FixedPoint!","text":"FixedPoint!(SC::SelfCons; tol::Float64=1e-6, max_iter::Int64=100) \nFixedPoint!(SC::SelfCons, fileName::String; tol::Float64=1e-6, max_iter::Int64=100, checkpoint_interval::Int64 = 10) \n\nRuns a fixed point iteration on the SelfCons SC with a convergence tolerance of tol per input, and a maximum iteration cutoff of max_iter. Optionally can also pass a fileName to checkpoint and save the results in. Can pass a kwarg checkpoint_interval to set the checkpoint frequency.\n\n\n\n\n\n","category":"method"},{"location":"PlotSelfCons/#FixedPointToolkit.PlotSelfCons","page":"Plotting Results","title":"FixedPointToolkit.PlotSelfCons","text":"","category":"section"},{"location":"PlotSelfCons/","page":"Plotting Results","title":"Plotting Results","text":"Modules = [FixedPointToolkit, FixedPointToolkit.PlotSelfCons]\nPrivate = false\nPages   = [\"PlotSelfCons.jl\"]","category":"page"},{"location":"PlotSelfCons/#FixedPointToolkit.PlotSelfCons.Plot_History-Union{Tuple{S}, Tuple{R}, Tuple{T}, Tuple{SelfCons{T, R, S}, String}} where {T<:Function, R<:Function, S<:Union{Number, Vector{<:Number}}}","page":"Plotting Results","title":"FixedPointToolkit.PlotSelfCons.Plot_History","text":"Plot_History(sc::SelfCons{T, R, S}, arg::String ; indices::Vector{Int64} = collect(1:length(sc.Initial)), plot_legend::Bool = true) where {T<:Function, R<:Function, S<:Union{Number, Vector{<:Number}}}\n\nPlotting function to plot the flow of sc.VIns, sc.VOuts, or the convergence as a function of iteration, when arg = \"inputs\", \"outputs\", or \"convergence\" respectively. Optional argument indices is if you only want to plot a subset of the vector arguments. log_plot is if you want to plot the semi-log plot of convergence vs iteration\n\n\n\n\n\n","category":"method"},{"location":"Scheduler/#FixedPointToolkit.Scheduler","page":"Schedulers","title":"FixedPointToolkit.Scheduler","text":"","category":"section"},{"location":"Scheduler/","page":"Schedulers","title":"Schedulers","text":"Modules = [FixedPointToolkit, FixedPointToolkit.Scheduler]\nPrivate = false\nPages   = [\"Scheduler.jl\"]","category":"page"},{"location":"Scheduler/#FixedPointToolkit.Scheduler.ExponentialScheduling-Tuple{Float64}","page":"Schedulers","title":"FixedPointToolkit.Scheduler.ExponentialScheduling","text":"ExponentialScheduling(alpha::Float64; iter::Int64, max_iter::Int64, rate::Float64 = 1.0) --> Float64\n\nReturns an alpha value descreased exponentially with the iteration iter with some rate rate.\n\n\n\n\n\n","category":"method"},{"location":"Scheduler/#FixedPointToolkit.Scheduler.QuadraticScheduling-Tuple{Float64}","page":"Schedulers","title":"FixedPointToolkit.Scheduler.QuadraticScheduling","text":"QuadraticScheduling(alpha::Float64; iter::Int64, max_iter::Int64) --> Float64\n\nReturns an alpha value descreased quadratically with the iteration iter.\n\n\n\n\n\n","category":"method"},{"location":"Scheduler/#Hot-to-write-your-own-Scheduler","page":"Schedulers","title":"Hot to write your own Scheduler","text":"","category":"section"},{"location":"Scheduler/","page":"Schedulers","title":"Schedulers","text":"If you want to design your own scheduler, you need to follow certain guidelines","category":"page"},{"location":"Scheduler/","page":"Schedulers","title":"Schedulers","text":"Define your function as follows","category":"page"},{"location":"Scheduler/","page":"Schedulers","title":"Schedulers","text":"    function CustomScheduler(x::Float64 ; iter::Int64, max_iter::Int64, kwargs...)\n        ##### Do something with x, iter, max_iter, and any other keyword argument in kwargs\n        return x_new\n    end","category":"page"},{"location":"Scheduler/","page":"Schedulers","title":"Schedulers","text":"Every other argument you pass to your CustomScheduler must be a keyword argument whose default values are set to whatever you want to use during the iterations. \nYou cannot pass these extra kwargs during the Fixed point iteration. That is why it is crucial to set their default values to what you need.\nSuppose you want the mixing, alpha to follow some relation w.r.t iteration i, alpha = alpha(i). What you want your CustomScheduler to return is the next iteration of the mixing, alpha(i+1), given that alpha(i), i, and other relevant parameters are passed to it. \nEg. for an exponential scheduling, ","category":"page"},{"location":"Scheduler/","page":"Schedulers","title":"Schedulers","text":"    CustomScheduler(x ; iter = i, max_iter = N, rate = r) = x * exp(-r/N)","category":"page"},{"location":"SelfCons/#FixedPointToolkit.SelfConsistency","page":"Self-Consistency","title":"FixedPointToolkit.SelfConsistency","text":"","category":"section"},{"location":"SelfCons/","page":"Self-Consistency","title":"Self-Consistency","text":"Modules = [FixedPointToolkit, FixedPointToolkit.SelfConsistency]\nPrivate = false\nPages   = [\"SelfCons.jl\"]","category":"page"},{"location":"SelfCons/#FixedPointToolkit.SelfConsistency.SelfCons","page":"Self-Consistency","title":"FixedPointToolkit.SelfConsistency.SelfCons","text":"SelfCons{T<:Function, R<:Function, S<:Union{Number, Vector{<:Number}}} is a data type representing a general function whose fixed point you want to calculate.\n\nAttributes\n\nF               ::  T: The function for which the fixed point needs to be calulcated.\nF_args          ::  Tuple: A tuple of arguments held fixed for the function F.\nF_kwargs        ::  Dict{Symbol, Any}: a dictionary of keyword arguments helf fixed for the function F.\nInitial         ::  S : the initial guess to start the fixed point iteration.\nVIns            ::  Vector{S}: the history of all the inputs used throughout the fixed point iteration.\nVOuts           ::  Vector{S}: the history of all the outputs used throughout the fixed point iteration.\nUpdate          ::  R: the update method being used during the fixed point iteration. eg. SimpleMixing.\nUpdate_kwargs   ::  Dict{Symbol, Any}: some keyword arguments held fixed for the Update function.\n\nInitialize this structure using \n\nSelfCons(F::T, Update::R, Initial::S ; F_args::Tuple = (), F_kwargs::Dict = Dict(), Update_kwargs::Dict = Dict()) where {T<:Function, R<:Function, S<:Union{Number, Vector{<:Number}}}\n\n\n\n\n\n","category":"type"},{"location":"Checkpointer/#FixedPointToolkit.Checkpointer","page":"Checkpointing","title":"FixedPointToolkit.Checkpointer","text":"","category":"section"},{"location":"Checkpointer/","page":"Checkpointing","title":"Checkpointing","text":"Modules = [FixedPointToolkit, FixedPointToolkit.Checkpointer]\nPrivate = false\nPages   = [\"Checkpointer.jl\"]","category":"page"},{"location":"Checkpointer/#FixedPointToolkit.Checkpointer.ReCreateSelfCons-Union{Tuple{R}, Tuple{T}, Tuple{Dict, T, R}} where {T<:Function, R<:Function}","page":"Checkpointing","title":"FixedPointToolkit.Checkpointer.ReCreateSelfCons","text":"ReCreateSelfCons(checkpoint::Dict, F::T, Update::R) :: SelfCons where {T<:Function, R<:Function}\n\nReturn a SelfCons structure from a checkpoint dictionary and the function F and Update (which are not saved during checkpointing).\n\n\n\n\n\n","category":"method"},{"location":"Checkpointer/#FixedPointToolkit.Checkpointer.read_checkpoint-Tuple{String}","page":"Checkpointing","title":"FixedPointToolkit.Checkpointer.read_checkpoint","text":"read_checkpoint(fileName::String )\n\nRead a JLD2 file fileName (fileName must end with .jld2) and return the checkpoint in the form of a dictionary. \n\n\n\n\n\n","category":"method"},{"location":"Checkpointer/#FixedPointToolkit.Checkpointer.save_checkpoint-Tuple{String, SelfCons, Dict{Symbol, Real}}","page":"Checkpointing","title":"FixedPointToolkit.Checkpointer.save_checkpoint","text":"save_checkpoint(fileName::String, sc::SelfCons, SelfConsParams::Dict{Symbol, Real})\n\nSave the relevant attributed of a SelfCons data structure in a JLD2 file fileName (fileName must end with .jld2).  Also saves some self-consistency parameters like maximum iteration, tolerance etc.\n\n\n\n\n\n","category":"method"},{"location":"#FixedPointToolkit.jl","page":"Introduction","title":"FixedPointToolkit.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FixedPointToolkit.jl is a Julia package meant for calculating fixed points of any scalar or vector functions, or equivalently, solve some system of self-consistent equations.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently supported :","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Fixed point iteration can work on any user defined function.\nUser has options to use different pre-defined update methods to be used during the iterations : Simple Mixing, Schduled Mixing, and Broyden Mixing.\nCan also implement a custom update function for user-specific scenarios.\nCan allow for different kinds of scheduling where the step-size in parameter space during the iterations changes. Right now supports Quadratic and Exponential scheduling, but can also support custom user-defined scheduler as well.\nCan checkpoint and save results into JLD2 files, and resume iterations from reading such files.\nCan plot results of inputs, outputs, and convergence as a function of iterations.","category":"page"},{"location":"Updates/#FixedPointToolkit.Updates","page":"Updates","title":"FixedPointToolkit.Updates","text":"","category":"section"},{"location":"Updates/","page":"Updates","title":"Updates","text":"Modules = [FixedPointToolkit, FixedPointToolkit.Updates]\nPrivate = false\nPages = [\"Updates.jl\"]","category":"page"},{"location":"Updates/#FixedPointToolkit.Updates.BroydenMixing-Union{Tuple{Z}, Tuple{N}, Tuple{T}, Tuple{N, N, T}} where {T<:Function, N<:Union{Number, Vector{<:Number}}, Z<:Union{Number, Matrix{<:Number}}}","page":"Updates","title":"FixedPointToolkit.Updates.BroydenMixing","text":"BroydenMixing(VIn::N, VOut::N, F::T ; F_args::Tuple = (), F_kwargs::Dict = Dict() , alpha::Float64 = 0.5, B::Z = alpha*Matrix(1.0I, length(VIn), length(VIn)), _extra...) --> Dict where {T<:Function, N<:Union{Number, Vector{<:Number}}, Z<:Union{Number,Matrix{<:Number}}}\n\nReturns a dictionary containing the following\n\n\"VInNext\" : simple mixing of VIn and VOut with weight (1-beta) and beta respectively, where beta = Scheduler(alpha), which may change with iteration. \n\"VOutNext\" : The function F evaluated at VInNExt, with fixed args F_args and kwargs F_kwargs.\n\"Delta\" : The norm difference b/w the next input and output.\n\"kwargs\" : the kwargs of this function itself, to be used by a subsequent function call in the next fixed point iteration. Here, the B-matrix is updated every iteration according to Broyden mixing rules.\n\n\n\n\n\n","category":"method"},{"location":"Updates/#FixedPointToolkit.Updates.ScheduledMixing-Union{Tuple{R}, Tuple{N}, Tuple{T}, Tuple{N, N, T}} where {T<:Function, N<:Union{Number, Vector{<:Number}}, R<:Function}","page":"Updates","title":"FixedPointToolkit.Updates.ScheduledMixing","text":"ScheduledMixing(VIn::N, VOut::N, F::T ; F_args::Tuple = (), F_kwargs::Dict = Dict() , alpha::Float64 = 0.5, iter::Int64 = 1, max_iter::Int64 = 1, Scheduler :: R = QuadraticScheduling, _extra...) --> Dict   where {T<:Function, N<:Union{Number, Vector{<:Number}}, R<:Function}\n\nReturns a dictionary containing the following\n\n\"VInNext\" : Simple mixing of VIn and VOut with weight (1-beta) and beta respectively, where beta = Scheduler(alpha), which may change with iteration. \n\"VOutNext\" : The function F evaluated at VInNExt, with fixed args F_args and kwargs F_kwargs.\n\"Delta\" : The norm difference b/w the next input and output.\n\"kwargs\" : the kwargs of this function itself, to be used by a subsequent function call in the next fixed point iteration. Here, the alpha value is updated every iteration using a Scheduler.\n\n\n\n\n\n","category":"method"},{"location":"Updates/#FixedPointToolkit.Updates.SimpleMixing-Union{Tuple{N}, Tuple{T}, Tuple{N, N, T}} where {T<:Function, N<:Union{Number, Vector{<:Number}}}","page":"Updates","title":"FixedPointToolkit.Updates.SimpleMixing","text":"SimpleMixing(VIn::N, VOut::N, F::T ; F_args::Tuple = (), F_kwargs::Dict = Dict() , alpha::Float64 = 0.5, _extra...) --> Dict   where {T<:Function, N<:Union{Number, Vector{<:Number}}}\n\nReturns a dictionary containing the following\n\n\"VInNext\" : Simple mixing of VIn and VOut with weight (1-alpha) and alpha respectively. \n\"VOutNext\" : The function F evaluated at VInNExt, with fixed args F_args and kwargs F_kwargs.\n\"Delta\" : The norm difference b/w the next input and output.\n\"kwargs\" : the kwargs of this function itself, to be used by a subsequent function call in the next fixed point iteration. Since this is simple mixing, alpha is held constant.\n\n\n\n\n\n","category":"method"},{"location":"Updates/#Hot-to-write-your-own-Update","page":"Updates","title":"Hot to write your own Update","text":"","category":"section"},{"location":"Updates/","page":"Updates","title":"Updates","text":"If you want to design your own update function, you need to follow certain guidelines","category":"page"},{"location":"Updates/","page":"Updates","title":"Updates","text":"Define your function as follows (F is the function whose fixed point is being calculated)","category":"page"},{"location":"Updates/","page":"Updates","title":"Updates","text":"function CustomUpdate(VIn::N, VOut::N, F::T ; F_args::Tuple = (), F_kwargs::Dict = Dict(), kwargs..., _extra...) :: Dict where {T<:Function, N<:Union{Number, Vector{<:Number}}}\n    ##### Get VInNext by doing something on VIn, VOut, and stuff in kwargs.\n    VOutNext    =   F(VInNext, F_args... ; F_kwargs...)\n\n    ##### If you want to include scheduling, you can now include a function which updates the kwargs themselves --> call then new_kwargs (MUST contain all the keys of kwargs, even if they are unchanged)\n\n    return Dict(\"VInNext\"   => VInNext, \n                \"VOutNext\"  => VOutNext,\n                \"Delta\"     => norm(VOutNext - VInNext) / sqrt(length(VInNext)), \n                \"kwargs\"    => new_kwargs)\nend","category":"page"},{"location":"Updates/","page":"Updates","title":"Updates","text":"Every other argument you pass to your CustomUpdate must be a keyword argument. \nUnlike CustomScheduler, you will be able to pass whatever kwargs you want to CustomUpdate when you begin the Fixed Point iterations.. ","category":"page"}]
}
